{"meta":{"title":"GoCaff","subtitle":"Go茶馆","description":"曾焜锐个人博客,Go茶馆","author":"RUI","url":"https://gocaff.cn","root":"/"},"pages":[{"title":"categories","date":"2023-01-26T17:02:10.000Z","updated":"2024-11-08T03:02:29.159Z","comments":false,"path":"categories/index.html","permalink":"https://gocaff.cn/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2023-01-28T08:18:36.000Z","updated":"2024-11-08T03:02:29.158Z","comments":true,"path":"about/index.html","permalink":"https://gocaff.cn/about/index.html","excerpt":"","text":"@timeline{ 2016@item{ 6月30日🏫离开校园广东理工学院软件技术 } @item{ 7月20日💻实习加入初创公司实习。 } 2017@item{ 6月24日🏃‍前往深圳加入一家互联网金融公司，成为后端开发一员。 } 2018@item{ 6月16日🎉全栈开发加入一家直播平台公司，全栈开发，对高可用、高并发有了深入研究。 } 2019@item{ 8月16日🐧电子政务加入一家电子政务类公司，后端开发，对电子政务领域有了深入研究。 } }"},{"title":"tags","date":"2023-01-26T17:00:52.000Z","updated":"2024-11-08T03:02:29.159Z","comments":false,"path":"tags/index.html","permalink":"https://gocaff.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"shell中 /dev/null 2>&1 是什么?","slug":"dev-null-2-1","date":"2019-04-26T02:50:43.000Z","updated":"2024-11-08T03:02:29.157Z","comments":true,"path":"posts/dev-null-2-1.html","permalink":"https://gocaff.cn/posts/dev-null-2-1.html","excerpt":"","text":"shell重定向介绍就像我们平时写的程序一样，一段程序会处理外部的输入，然后将运算结果输出到指定的位置。在交互式的程序中，输入来自用户的键盘和鼠标，结果输出到用户的屏幕，甚至播放设备中。而对于某些后台运行的程序，输入可能来自于外部的一些文件，运算的结果通常又写到其他的文件中。而且程序在运行的过程中，会有一些关键性的信息，比如异常堆栈，外部接口调用情况等，这些都会统统写到日志文件里。 shell 脚本也一样，但是我们一般在使用 shell 命令的时候，更多地还是通过键盘输入，然后在屏幕上查看命令的执行结果。如果某些情况下，我们需要将 shell 命令的执行结果存储到文件中，那么我们就需要使用输入输出的重定向功能。 文件描述符当执行 shell 命令时，会默认打开3个文件，每个文件有对应的文件描述符来方便我们使用： 类型 文件描述 默认情况 对应文件句柄位置 标准输入（standard input） 0 从键盘获得输入 &#x2F;proc&#x2F;self&#x2F;0 标准输出（standard output） 1 输出到屏幕（即控制台） &#x2F;proc&#x2F;self&#x2F;1 错误输出（error output） 2 输出到屏幕（即控制台） &#x2F;proc&#x2F;self&#x2F;2 所以我们平时在执行 shell 命令中，都默认是从键盘获得输入，并且将结果输出到控制台上。但是我们可以通过更改文件描述符默认的指向，从而实现输入输出的重定向。比如我们将 1 指向文件，那么标准的输出就会输出到文件中。 输出重定向输出重定向的使用方式很简单，基本的一些命令如下： 命令 介绍 command &gt;filename 把标准输出重定向到新文件中 command 1&gt;filename 同上 command &gt;&gt;filename 把标准输出追加到文件中 command 1&gt;&gt;filename 同上 command 2&gt;filename 把标准错误重定向到新文件中 command 2&gt;&gt;filename 把标准错误追加到新文件中 我们使用&gt;或者&gt;&gt;对输出进行重定向。符号的左边表示文件描述符，如果没有的话表示1，也就是标准输出，符号的右边可以是一个文件，也可以是一个输出设备。当使用&gt;时，会判断右边的文件存不存在，如果存在的话就先删除，然后创建一个新的文件，不存在的话则直接创建。但是当使用&gt;&gt;进行追加时，则不会删除原来已经存在的文件。 为了更好地理解输出重定向，感受重定向的“魅力”，我们看一下以下的例子：我们创建一个测试目录，目录下面仅有一个 a.txt 文件。 12345678# tree.└── a.txt0 directories, 1 file# ls a.txt b.txtls: 无法访问b.txt: 没有那个文件或目录a.txt 在我们执行 ls a.txt b.txt 之后，一共有两种输出，其中 ls: 无法访问 b.txt: 没有那个文件或目录是错误输出，a.txt是标准输出。 123456789# ls a.txt b.txt 1&gt;outls: 无法访问b.txt: 没有那个文件或目录# cat outa.txt# ls a.txt b.txt &gt;&gt;outls: 无法访问b.txt: 没有那个文件或目录# cat outa.txta.txt 在上述命令中，我们将原来的标准输出重定向到了 out 文件中，所以控制台只剩下了错误提示。并且当执行了追加操作时，out 文件的内容非但没有被清空，反而又多了一条 a.txt。 同理，我们也可以将错误输出重定向到文件中： 123456789# ls a.txt b.txt 2&gt;erra.txt# cat errls: 无法访问b.txt: 没有那个文件或目录# ls a.txt b.txt &gt;out 2&gt;err# cat outa.txt# cat errls: 无法访问b.txt: 没有那个文件或目录 看到这里，朋友们可能会发现 &gt;out 2&gt;err 和我们在一开头提到的 &gt;/dev/null 2&gt;&amp;1 已经很像了，别急，这待会再说。 输入重定向在理解了输出重定向之后，理解输入重定向就会容易得多。对输入重定向的基本命令如下： 命令 介绍 command &lt;filename 以filename文件作为标准输入 command 0&lt;filename 同上 command &lt;&lt;delimiter 从标准输入中读入，直到遇到delimiter分隔符 我们使用&lt;对输入做重定向，如果符号左边没有写值，那么默认就是0。 我们这次以 cat 命令为例，如果 cat 后面没有跟文件名的话，那它的作用就是将标准输入（比如键盘）回显到标准输出（比如屏幕）上： 12345# cat123123testtest 我们可以将利用输入重定向，将我们在键盘上敲入的字符写入到文件中。我们需要使用 ctrl+c 来结束输入： 1234567# cat &gt;out123test^C# cat out123test 好了，此时我们觉得自己在键盘上敲比较累，还是直接让 cat 读取一个文件吧。那么我们需要利用输入重定向： 1234567# cat inputaaa111# cat &gt;out &lt;input# cat outaaa111 神奇的事情发生了，out 文件里面的内容被替换成了 input 文件里的内容。那么 &lt;&lt; 又是什么作用呢？我们再看： 1234567# cat &gt;out &lt;&lt;end&gt; 123&gt; test&gt; end# cat out123test 我们看到，当我们输入完 cat &gt;out &lt;&lt;end，然后敲下回车之后，命令并没有结束，此时 cat 命令像一开始一样，等待你给它输入数据。然后当我们敲入 end 之后，cat 命令就结束了。end 之前输入的字符都已经被写入到了 out 文件中。这就是输入分割符的作用。 高级用法重定向绑定好了，在有了以上知识的基础上，我们再来看开头提到的 &gt;/dev/null 2&gt;&amp;1 。这条命令其实分为两命令，一个是 &gt;/dev/null，另一个是 2&gt;&amp;1 。 &gt;&#x2F;dev&#x2F;null这条命令的作用是将标准输出1重定向到 /dev/null 中。/dev/null 代表 linux 的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了 &gt;/dev/null 之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。 2&gt;&amp;1这条命令用到了重定向绑定，采用&amp;可以将两个输出绑定在一起。这条命令的作用是错误输出将和标准输出同用一个文件描述符，说人话就是错误输出将会和标准输出输出到同一个地方。 linux 在执行 shell 命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令，所以 &gt;/dev/null 2&gt;&amp;1 的作用就是让标准输出重定向到 /dev/null 中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了 /dev/null 中，错误输出同样也被丢弃了。执行了这条命令之后，该条 shell 命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。 &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 VS 2&gt;&amp;1 &gt;&#x2F;dev&#x2F;null再回到文章的开头，我说我弄反了 &gt;/dev/null 和 2&gt;&amp;1 拼装的顺序，导致出了一点小问题。乍眼看这两条命令貌似是等同的，但其实大为不同。刚才提到了，linux 在执行 shell 命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令。那么我们同样从左到右地来分析 2&gt;&amp;1 &gt;/dev/null： 2&gt;&amp;1，将错误输出绑定到标准输出上。由于此时的标准输出是默认值，也就是输出到屏幕，所以错误输出会输出到屏幕。&gt;/dev/null，将标准输出 1 重定向到 /dev/null 中。 我们用一个表格来更好地说明这两条命令的区别： 命令 标准输出 错误输出 &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 丢弃 丢弃 2&gt;&amp;1 &gt;&#x2F;dev&#x2F;null 丢弃 屏幕 &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 VS &gt;&#x2F;dev&#x2F;null 2&gt;&#x2F;dev&#x2F;null那么可能会有些同学会疑问，为什么要用重定向绑定，而不是像 &gt;/dev/null 2&gt;/dev/null 这样子重复一遍呢。 为了回答这个问题，我们回到刚才介绍输出重定向的场景。我们尝试将标准输出和错误输出都定向到 out 文件中： 1234# ls a.txt b.txt &gt;out 2&gt;out# cat outa.txt�法访问b.txt: 没有那个文件或目录 WTF ？竟然出现了乱码，这是为啥呢？这是因为采用这种写法，标准输出和错误输出会抢占往out文件的管道，所以可能会导致输出内容的时候出现缺失、覆盖等情况。现在是出现了乱码，有时候也有可能出现只有 error 信息或者只有正常信息的情况。不管怎么说，采用这种写法，最后的情况是无法预估的。 而且，由于 out 文件被打开了两次，两个文件描述符会抢占性的往文件中输出内容，所以整体 IO 效率不如 &gt;/dev/null 2&gt;&amp;1 来得高。 总结本文主要介绍了 linux 重定向的原理以及一些基本命令，并且详细地分析了 &gt;/dev/null 2&gt;&amp;1 这个命令以及一些注意点。 总而言之，在工作中用到最多的就是 nohup command &gt;/dev/null 2&gt;&amp;1 命令，希望大家能够好好掌握。","categories":[{"name":"liunx","slug":"liunx","permalink":"https://gocaff.cn/categories/liunx/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://gocaff.cn/tags/shell/"},{"name":"liunx","slug":"liunx","permalink":"https://gocaff.cn/tags/liunx/"}]}],"categories":[{"name":"liunx","slug":"liunx","permalink":"https://gocaff.cn/categories/liunx/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://gocaff.cn/tags/shell/"},{"name":"liunx","slug":"liunx","permalink":"https://gocaff.cn/tags/liunx/"}]}